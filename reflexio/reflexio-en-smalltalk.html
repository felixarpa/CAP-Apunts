<h1 id="reflexió-en-smalltalk">Reflexió en Smalltalk</h1>
<ul>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#pròleg">Pròleg</a>
<ul>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#les-metaclasses-en-7-parts">Les Mestaclasses en 7 parts</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#classes-indexades-i-variables-dinstància">Classes Indexades i Variables d’Instància</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#variables-de-classe-instància">Variables de class-instància</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#variables-de-classe">Variables de class</a></li>
</ul></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#reflexió">Reflexió</a>
<ul>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#introspecció">Introspecció</a>
<ul>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#inspecció-dobjectes">Inspecció d’objectes</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#consultar-el-codi">Consultar el codi</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#accedir-els-contexts-dexecució">Accedit els contexts d’execució</a></li>
</ul></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/reflexio/reflexio-en-smalltalk.md#intercessió">Intercessió</a>
<ul>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#sobreescriure-doesnotunderstand">Sobreescriure #doesNotUnderstand</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#classes-anònimes">Classes Anònimes</a></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#method-wrappers">Method Wrappers</a></li>
</ul></li>
</ul></li>
<li><a href="https://github.com/felixarpa/CAP-Reflexio/blob/master/reflexio/reflexio-en-smalltalk.md#continuacions">Continuacions</a></li>
</ul>
<h2 id="pròleg">Pròleg</h2>
<h3 id="les-metaclasses-en-7-parts">Les <em>Metaclasses</em> en 7 parts</h3>
<h4 id="tot-objecte-és-instància-duna-classe">1. Tot objecte és instància d’una classe</h4>
<h4 id="tota-classe-hereta-eventualment-dobject">2. Tota classe hereta eventualment d’Object</h4>
<p>Tot és un objecte. La classe de cada objecte hereta d’<em>Object</em></p>
<p>Quan un objecte rep un missatge, el mètode es busca al diccionari de mètodes de la seva classe, i, si cal, a les seves superclasses, fins arribar a <em>Object</em>.</p>
<p><em>Object</em> representa el comportament comú a tots els objectes (com la gestió d’errors, per exemple). Totes les classes haurien d’heretar d’<em>Object</em>.</p>
<h4 id="tota-classe-és-instància-duna-metaclasse">3. Tota classe és instància d’una metaclasse</h4>
<p>Com a Smalltalk tot és un objecte, les <strong>classes també son objectes</strong>. Cada classe <em>X</em> és l’única instància de la seva <em>metaclasse</em> anomenada <em>X class</em>.</p>
<p>Les <em>metaclasses</em> es crean quan es crea un classes de forma implícita. Les <em>metaclasses</em> no es comparteixen, cada classe és <strong>instància única</strong> de la seva <em>metaclasse</em>.</p>
<p><img src="./res/metaclasses00.png" /></p>
<p>Per accedir a la <em>metaclasse</em> d’una classe s’ha d’activar el <em>class side</em> al Pharo.</p>
<h4 id="la-jerarquia-de-metaclasses-és-equivalent-a-la-jerarquia-de-classes">4. La jerarquia de metaclasses és equivalent a la jerarquia de classes</h4>
<p><img src="./res/metaclasses01.png" /></p>
<h4 id="tota-metaclasse-hereta-de-class-i-behavior">5. Tota metaclasse hereta de Class i Behavior</h4>
<p><img src="./res/metaclasses02.png" /></p>
<h5 id="behavior">Behavior</h5>
<p>És el mínim estat necessari pels objectes que tenen instancies. Té l’interfície bàsica pel compilador.</p>
<h5 id="classdescription">ClassDescription</h5>
<p>Afageix algunes utilitats a <em>Behavior</em>. És una classe abstracte, les utilitats que proporciona estan pensades per <em>Class</em> i <em>Metaclass</em>.</p>
<h5 id="class">Class</h5>
<p>Representa el comportament comú de totes les classes (com, compilació, emmagatzematge de mètodes, variables d’instancia, etc).</p>
<h4 id="tota-metaclass-és-instància-de-metaclass">6. Tota metaclass és instància de Metaclass</h4>
<p><img src="./res/metaclasses03.png" /></p>
<h5 id="metaclass">Metaclass</h5>
<p>Representa el comportament comú de totes les <em>metaclasses</em></p>
<h4 id="la-metaclasse-de-metaclass-és-instància-de-metaclass">7. La metaclasse de Metaclass és instància de Metaclass</h4>
<p><img src="./res/metaclasses04.png" /></p>
<pre class="smalltalk"><code>testHierarchy
    &quot;The class hierarchy&quot;
    self assert: SnakeSquare superclass = BoardSquare.
    self assert: BoardSquare superclass = Object.
    self assert: Object superclass superclass = nil.
    &quot;The parallel metaclass hierarchy&quot;
    self assert: SnakeSquare class name = &#39;SnakeSquare class&#39;.
    self assert: SnakeSquare class superclass = BoardSquare class.
    self assert: BoardSquare class superclass = Object class.
    self assert: Object class superclass superclass = Class.
    self assert: Class superclass = ClassDescription.
    self assert: ClassDescription superclass = Behavior.
    self assert: Behavior superclass = Object.
    &quot;The Metaclass hierarchy&quot;
    self assert: SnakeSquare class class = Metaclass.
    self assert: BoardSquare class class = Metaclass.
    self assert: Object class class = Metaclass.
    self assert: Class class class = Metaclass.
    self assert: ClassDescription class class = Metaclass.
    self assert: Behavior class class = Metaclass.
    self assert: Metaclass superclass = ClassDescription.
    &quot;The fixpoint&quot;
    self assert: Metaclass class class = Metaclass</code></pre>
<h3 id="classes-indexades-i-variables-dinstància">Classes Indexades i Variables d’Instància</h3>
<p>Tenim dues maneres de representar objectes <em>Variables d’Instància</em> per utilitzar-los, amb nom o indexades</p>
<ul>
<li>Amb <strong>nom</strong> <code>name</code> de <code>GamePlayer.class</code></li>
<li><strong>Indexada</strong> <code>#(Jack Jill) at: 1</code> seria “Jack”.</li>
</ul>
<p>Des del punt de vista més a baix nivell seria:</p>
<ul>
<li>Objectes amb referències a altres objectes (<em>pointer</em>)</li>
<li>Objectes amb arrays de bytes (<em>word</em>, <em>long</em>)</li>
</ul>
<p>Fem la diferència per raons d’eficiència: emmagatzemar arrays de <em>bytes</em> (com les strings de <strong>C</strong>) és més eficient que emmagatzemar un array de referències, cada una d’elles apuntant a un sol <em>byte</em> i ocupant una <em>word</em></p>
<p>Una <strong>variable indexada</strong> s’afegeix implícitament a la llista de <strong>variables d’instància</strong>.</p>
<ul>
<li>Només hi ha una variable indexada (d’instància) per classe</li>
<li>Accés amb <code>#at:</code> i amb <code>#at:put:</code></li>
</ul>
<p>Les subclasses d’una classe indexable han de ser també indexades</p>
<h4 id="indexedobject">IndexedObject</h4>
<p>Declaració de la classe:</p>
<pre class="smalltalk"><code>Object variableSubclass: #IndexedObject
    instanceVariableNames: &#39;&#39;
    classVariableNames: &#39;&#39;
    category: &#39;ClassesIndexades&#39;</code></pre>
<p>Exemple d’us:</p>
<pre class="smalltalk"><code>(IndexedObject new: 2)
    at: 1 put: &#39;Fèlix&#39;;
    at: 2 put: &#39;Arribas&#39;;
    at: 1. &quot; Print it =&gt; &#39;Fèlix&#39; &quot;</code></pre>
<p><a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/smalltalk/ClassesIndexades.package/IndexedObject.class">Implementació</a></p>
<h3 id="variables-de-classe-instància">Variables de classe-instància</h3>
<p>Les classes són objectes, instàncies de la seva metaclasse, així que poden tenir variables d’instància.</p>
<h4 id="exemple-el-patró-singleton">Exemple: El patró Singleton</h4>
<p>Volem que la classe sigui singleton (<a href="https://github.com/felixarpa/CAP-Reflexio/tree/master/smalltalk/Patterns.package/Singleton.class">codi</a>).</p>
<pre class="smalltalk"><code>Object subclass: #Singleton
    instanceVariableNames: &#39;&#39;
    classVariableNames: &#39;&#39;
    category: &#39;Patterns&#39;</code></pre>
<p>I al class side (metaclasse):</p>
<pre class="smalltalk"><code>Singleton class
    instanceVariableNames: &#39;uniqueInstance&#39;</code></pre>
<p>Ara toca controlar la creació de lobjecte <em>Singleton</em> i l’access a <em>uniqueInstance</em>:</p>
<pre class="smalltalk"><code>new
    &quot;You cannot create a new singleton object&quot;
    self error: &#39;Use uniqueInstance to get the unique instance of this object&#39;</code></pre>
<pre class="smalltalk"><code>uniqueInstance
    &quot;get the unique instance of this class&quot;
    uniqueInstance isNil
       ifTrue: [ uniqueInstance := self basicNew initialize ].
    ^ uniqueInstance</code></pre>
<h3 id="variables-de-classe">Variables de classe</h3>
<p>Serveixen per compartir informació entre instàncies d’una classe. Son variables compartides i direcament accessibles per totes les instàncies de la classe i la subclasse. Comença amb una lletra majúscula.</p>
<h2 id="reflexió">Reflexió</h2>
<h3 id="introspecció">Introspecció</h3>
<p>Fent introspecció a Smalltalk podem arribar a inspecionar objectes, consultar el seu codi i també accedir els contests d’execució.</p>
<h4 id="inspecció-dobjectes">Inspecció d’objectes</h4>
<p>Una classe té un format, una superclasse i un diccionari de mètodes. Com hem vist abans cada classe té una <em>metaclasse</em> que es crea implicitament quan es crea la classe. On es crea aquesta metaclasse i la classe com a instància? Ho podem trobar a <code>SlotClassBuilder &gt;&gt; #buildNewClass</code>. En aquesta funció es crea un metaclasse nova <code>metaclass := Metaclass new.</code> i s’instancia creant una nova classe <code>newClass := metaclass new.</code>.</p>
<pre class="smalltalk"><code>buildNewClass
    | metaclass newClass |
    metaclass := Metaclass new.
    metaclass
        superclass: self superMetaclass
        withLayoutType: FixedLayout
        slots: classSlots.

    newClass := metaclass new.
    newClass setName: name.
    
    newClass
        superclass: superclass
        withLayoutType: self layoutClass
        slots: slots.

    newClass declare: sharedVariablesString.
    newClass sharing: sharedPoolsString.
    
    installer classAdded: newClass inCategory: category.
    
    installer installTraitComposition: traitComposition on: newClass.
    installer installTraitComposition: classTraitComposition on: metaclass.
    
    ^ newClass</code></pre>
<p>Cal distingir entre <em>metaobjectes</em> i <em>metaclasses</em>. Amb el nom ja ens ho podem imaginar. Una <em>metaclasse</em> és la classe de les classes. Una classe les instàncies de la qual són classes. En canvi un <em>metaobjexte</em> és un objecte que descriu o manipula altres objectes, per exemple:</p>
<ul>
<li><strong>Estructura:</strong> <code>Behavior</code>, <code>ClassDescription</code>, <code>Class</code>, <code>Metaclass</code>, <code>ClassBuilder</code></li>
<li><strong>Semántica:</strong> <code>Compiler</code>, <code>Decompiler</code>, <code>IRBuilder</code></li>
<li><strong>Comportament:</strong> <code>CompiledMethod</code>, <code>BlockContext</code>, <code>Message</code>, <code>Exception</code></li>
<li><strong>Control de l’estat:</strong> <code>BlockContext</code>, <code>Process</code>, <code>ProcessorScheduler</code></li>
<li><strong>Recursos:</strong> <code>WeakArray</code></li>
<li><strong>Noms:</strong> <code>SystemDictionary</code></li>
<li><strong>Llibreries:</strong> <code>MethodDictionary</code>, <code>ClassOrganizer</code></li>
</ul>
<p>Aquests <em>metaobjectes</em> tene les seves <em>metaoperacions</em>. Les metaoperacions són les que ofereixen informació (o <em>metainformació</em>) dels objectes.</p>
<p>Utilitzem la <em>metaoperació</em> <code>instVarNamed:</code> per accedir a la variable d’un objecte pel nom i fem servir <code>put:</code> per canviar el seu valor.</p>
<pre class="smalltalk"><code>| punt |
punt := 10@2.
punt class. &quot;Point&quot;
punt x. &quot;10&quot;
punt instVarNamed: &#39;x&#39;. &quot;10&quot;
punt x: 4. &quot;Point doesNotUnderstand x:&quot; &quot;No podem modificar la variable x de punt d&#39;aquesta manera&quot;
punt instVarNamed: &#39;x&#39; put: 4.
punt &quot;(4@2)&quot;</code></pre>
<p>També podem accedir a al <em>metainformació</em> (<code>Object &gt;&gt; #class</code>, <code>Object &gt;&gt; #identityHash</code>) I canviar-la (<code>Object &gt;&gt; #primitiveChangeClassTo:</code>, <code>ProtoObject &gt;&gt; #become:</code>, <code>Object &gt;&gt; #becomeForward:</code>).</p>
<h6 id="primitivechangeclassto">primitiveChangeClassTo</h6>
<p>Canvia la classe de l’objecte receptor del missatge per la classe del objecte argument. Les dues classes tenen la mateixa estructura a les seves instancies. Per això quan creem el metode <code>thisIsATest</code> <em>browser</em> ho entén pero un nou <em>Browser</em> no.</p>
<pre class="smalltalk"><code>testPrimitiveChangeClassTo
    | behavior browser |
    behavior := Behavior new.
    behavior superclass: Browser.
    behavior setFormat: Browser format.
    browser := Browser new.
    
    browser primitiveChangeClassTo: behavior new.
    behavior compile: &#39;thisIsATest ^ 2&#39;.
    
    self assert: browser thisIsATest = 2.
    self should: [ Browser new thisIsATest ] raise: MessageNotUnderstood.</code></pre>
<h6 id="become">become</h6>
<p>Intercanvia totes les referències d’un objecte a l’altre i vice-versa. <code>punt1</code> passa a ser <code>punt3</code> i <code>punt3</code> passa a ser <code>punt1</code>.</p>
<pre class="smalltalk"><code>testBecome
    | punt1 punt2 punt3 |
    punt1 := 0@0.
    punt2 := punt1.
    punt3 := 100@100.
    punt1 become: punt3.
    self assert: punt1 = (100@100).
    self assert: punt1 == punt2.
    self assert: punt3 = (0@0).</code></pre>
<h6 id="becomeforward">becomeForward</h6>
<p>Intercanvia totes les referències d’un objecte a l’altre. <code>punt1</code> passa a ser <code>punt3</code>. <code>punt3</code> no canvia.</p>
<pre class="smalltalk"><code>testBecomeForward
    | punt1 punt2 punt3 |
    punt1 := 0@0.
    punt2 := punt1.
    punt3 := 100@100.
    punt1 becomeForward: punt3.
    self assert: punt1 = (100@100).
    self assert: punt1 == punt2.
    self assert: punt2 == punt3.</code></pre>
<h4 id="consultar-el-codi">Consultar el codi</h4>
<p>A Pharo podem veure el codi de totes les classes i métodes gràcies al System Navigation, però ademés podem accedir a informació “interessant” sobre aquest codi com per exemple les subclasses (<code>subclasses</code>, també les subclasses de les subclasses amb <code>allSubclasses</code>), les linies de codi (<code>linesOfCode</code>), superclasses (<code>allSuperclasses</code>), etc.</p>
<p>Com hem vist abans, totes les classes són subclasse de <em>Behavior</em>. Behavior té un diccionari de metodes <code>MethodDictionari</code>, un diccionari de <code>CompiledMethod</code>. Podem accedir a aquests metodes accedint per nom a al diccionari.</p>
<pre class="smalltalk"><code>5 factorial.
5 perform: #factiorial.</code></pre>
<h4 id="accedir-els-contexts-dexecució">Accedir els contexts d’execució</h4>
<p>La pila d’execució por ser reificada i maniupala. <code>thisContext</code> és una pseudo-variable que ens dóna accés a la pila.</p>
<p>Creem <code>Integer &gt;&gt; #factorial2</code> per veure el funcionament de la pila.</p>
<pre class="smalltalk"><code>factorial2
    &quot;Answer the factorial of the receiver.&quot;

    self = 0 ifTrue: [ thisContext explore. self halt. ^ 1].
    self &gt; 0 ifTrue: [^ self * (self - 1) factorial2].
    self error: &#39;Not valid for negative integers&#39;</code></pre>
<p><code>thisContext explore</code> ens obrirà el context actual i <code>self halt</code> aturarà l’execució. Com la functió factorial és recursiva, quan ara fem, per exemple, <code>5 factorial</code> veurem totes les crides recursives.</p>
<blockquote>
<p>El metode <code>factorial2</code> està implementat al paquet <em>Reflexió</em>. Així que només cal executar al Workspace <code>5 factorial2</code>.</p>
</blockquote>
<p>Com tot és un objecte modelitzem la pila d’execució amb objectes, concretament amb la classe <code>MethodContext</code>. Aquesta classe gestiona l’espai associat a l’execució d’un <code>CompiledMethod</code> (PC, el mètode en si, <em>sender</em> i <em>receiver</em>). El <em>sender</em> és el previ MethodContext.</p>
<p>Al aturar el context amb el mètode <code>halt</code> hem d’anar amb cuidado. No podem posar <code>halt</code> en mètodes que s’utilitzen sovint ja que es començarà a aturar tot. Podem crear el metode <code>haltIf</code>, que s’atura només si el mètode ha estat invocat des d’algun altre amb un selector determina:</p>
<pre class="smalltalk"><code>haltIf: aSelector
    | context |
    context := thisContext.
    [ context sender isNil ]
        whileFalse: [
            context :=  context sender.
            (context selector = aSelector)
                ifTrue: [ Halt signal ]
        ].</code></pre>
<pre class="smalltalk"><code>foo
    self haltIf: #fighters.
    ^ &#39;foo&#39;</code></pre>
<pre class="smalltalk"><code>fighters
    ^ (self foo), &#39;fighters&#39;</code></pre>
<p>En el mètode <code>#foo</code>, diu que faci <code>halt</code> si <code>#foo</code> és cridada desde <code>#fighters</code>. El mètode <code>#figthers</code> crida a <code>#foo</code>, al fer <code>#foo</code> <code>#fighters</code>, salta.</p>
<pre class="smalltalk"><code>HaltDemo new foo. &quot; &#39;foo&#39; &quot;
HaltDemo new fighters. &quot; fa Halt&quot;</code></pre>
<p>Halt</p>
<pre><code>HaltDemo        haltIf:
HaltDemo        foo
HaltDemo        fighters</code></pre>
<h5 id="blockwithexit">BlockWithExit</h5>
<pre class="smalltalk"><code>Object subclass: #BlockWithExit
    instanceVariableNames: &#39;block exitBlock&#39;
    classVariableNames: &#39;&#39;
    category: &#39;Reflexio&#39;</code></pre>
<h6 id="blockwithexit-class">BlockWithExit class</h6>
<pre class="smalltalk"><code>with: aBlock
    ^ self new with: aBlock </code></pre>
<h6 id="blockwithexit-1">BlockWithExit</h6>
<pre class="smalltalk"><code>with: aBlock
    block := aBlock </code></pre>
<pre class="smalltalk"><code>value
    exitBlock := [^ nil].
    ^ block value.</code></pre>
<pre class="smalltalk"><code>exit
    exitBlock value</code></pre>
<h6 id="blockclosure">BlockClosure</h6>
<pre class="smalltalk"><code>withExit
    ^ BlockWithExit with: self</code></pre>
<h6 id="exemple">Exemple</h6>
<pre class="smalltalk"><code>| theLoop coll |
Transcript open.
coll := OrderedCollection new.
1000 timesRepeat: [ coll add: 1000 atRandom ].
theLoop := [
    coll do: [ :each |
        Transcript show: each asString; cr.
        (each &lt; 100)
            ifTrue: [theLoop exit]
    ]
] withExit.
theLoop value.</code></pre>
<p><strong>BlockWithExit</strong> és una variant de <strong>BlockClosure</strong> que permet sortir de la closure cridant exit. En aquest codi es crea una llista de 1000 elements amb un nombre aleatori entre 0 i 1000. En el bloc de <code>theLoop</code> s’itera per tota la llista (<code>coll do: [ :each |</code>), es mostra el valor (<code>Transcript show: each asString; cr.</code>) i si el valor és menor de 100 (<code>(each &lt; 100) ifTrue:</code>) es surt del bloc (<code>[theLoop exit]</code>).</p>
<p>Com el bloc que es crea és el per defecte de Smalltalk (<code>BlockClosure</code>) afegim el metode <code>#withExit</code> que crea un <code>BlockWithExit</code>.</p>
<h3 id="intercessió">Intercessió</h3>
<h4 id="sobreescriure-doesnotunderstand">Sobreescriure <code>#doesNotUnderstand:</code></h4>
<p>Cal crear un objecte mínim. Embolica un objecte normal (<em>wrap</em>), no enten quasi res i redefineix <code>#doesNotUnerstand:</code>. És superclasse de <code>nil</code> o <code>ProtoObject</code> per no tenir la implementació normal de <code>#doesNotUnerstand:</code>. Finalment utilitxa el metode <code>#become:</code> per substituir i controlar l’objecte a controlar.</p>
<pre class="smalltalk"><code>ProtoObject subclass: #LoggingProxy
    instanceVariableNames: &#39;subject invocationCount&#39;
    classVariableNames: &#39;&#39;
    category: &#39;Reflexio&#39;</code></pre>
<p>La idea es col·locar aquest objecte entre el missatge i l’objecte receptor (<code>receiver</code>).</p>
<pre class="smalltalk"><code>initialize
    invocationCount := 0.
    subject := self.</code></pre>
<p>La variable d’instància <code>subject</code> serà on enviarem el missatge quan l’objecte no l’entengui:</p>
<pre class="smalltalk"><code>doesNotUnderstand: aMessage 
    Transcript show: &#39;performing &#39;, aMessage printString; cr.
    invocationCount := invocationCount + 1.
    ^ aMessage sendTo: subject</code></pre>
<h6 id="exemple-1">Exemple</h6>
<pre class="smalltalk"><code>testDelegation
    | point proxy |
    point := 1@2.
    proxy := LoggingProxy new.
    proxy become: point.

    self assert: point class = LoggingProxy.
    self assert: proxy class = Point.

    self assert: point invocationCount = 0.
    
    self assert: point + (3@4) = (4@6).
    self assert: point invocationCount = 1.</code></pre>
<p>Quan <code>point</code> es transforma en el proxy només sap fer <code>#doesNotUnderstand</code>. Ja no és <code>(1@2)</code>, el proxy passa ser-ho. Quan se li envia el missatge <code>#+</code> a <code>point</code>, ja no l’entén i executa <code>#doesNotUnderstand</code>. A <code>#doesNotUnderstant</code>, point escriu pel <code>Transcrip</code>, incrementa el <code>invocationCount</code> i finalment envia el missatge al <code>subject</code>.</p>
<p>La variable <code>subject</code> s’ha inicialitzat amb <code>self</code>, és a dir, <code>proxy</code>. <code>proxy</code> s’ha transformat en el punt <code>point</code>, ho podem veure en el primer <code>#assert:</code>. Aixi que envia el missatge a <code>proxy</code>, que ara és el punt <code>(1@2)</code> i si que l’enten.</p>
<h5 id="getters-on-demand">Getters “on demand”</h5>
<p>És pot sobreescriure el mètode <code>#doesNotUnderstand</code> per generar codi dinàmicament. Un cop la classe reb un missatge que no entén comprova si alguna de les seves variables d’instància té el nom del missatge, és a dir, s’està demanant pero com no te <em>getter</em> dóna error. Si la variable existeix compila <code>#nom ^ #nom</code> i l’executa. Si no existeix continua amb l’execució normal de <code>#doesNotUnderstand</code>.</p>
<pre class="smalltalk"><code>doesNotUnderstand: aMessage 
    | messageName |
    messageName := aMessage selector asString.
    (self class instVarNames includes: messageName)
        ifTrue: [self class compile: messageName , String cr , &#39; ^ &#39; , messageName.
            ^ aMessage sendTo: self].
    super doesNotUnderstand: aMessage</code></pre>
<h4 id="classes-anònimes">Classes anònimes</h4>
<p>Consisteix en crear un instancia de <code>Behavior</code>, definir els mètodes i posar-la entre la instància i la classe. Una classe anònima permet un control sel·lectiu, no dóna problemes amb el <code>self</code>, és eficient i dóna transparencia a l’usuari.</p>
<pre class="smalltalk"><code>| casseAnonima set |
casseAnonima := Behavior new.
casseAnonima superclass: Set;
    setFormat: Set format.

casseAnonima compile:
    &#39;add: anObject
        Transcript show: &#39;&#39;adding &#39;&#39;, anObject printString; cr.
        ^ super add: anObject&#39;.

set := Set new.
set add: 1.

set primitiveChangeClassTo: casseAnonima new.
set add: 2.</code></pre>
<p>El primer <code>#add</code> és normal, el segón és el compilat en el codi i mostra “<em>adding 2</em>” pel Transcript.</p>
<blockquote>
<p>Per que aquest codi funcioni cal crear aquests dos nous mètodes a la classe <code>TBehavior</code></p>
</blockquote>
<pre class="smalltalk"><code>basicLocalSelectors
    ^nil</code></pre>
<pre class="smalltalk"><code>basicLocalSelectors: aSetOrNil
    self subclassResponsibility</code></pre>
<h4 id="method-wrappers">Method Wrappers</h4>
<p>La idea és poder executar codi abans i despres de que s’executi el mètode que s’invoca. Es substitueix el mètode per un objecte que implementi <code>#run:with:in:</code>.</p>
<pre class="smalltalk"><code>Object subclass: #LoggingMethodWrapper
    instanceVariableNames: &#39;method reference invocationCount&#39;
    classVariableNames: &#39;&#39;
    category: &#39;Reflexio&#39;</code></pre>
<pre class="smalltalk"><code>initializeOn: aCompiledMethod
    method := aCompiledMethod.
    reference := aCompiledMethod methodReference.
    invocationCount := 0</code></pre>
<pre class="smalltalk"><code>run: aSelector with: anArray in: aReceiver
    invocationCount := invocationCount + 1.
    ^ aReceiver withArgs: anArray executeMethod: method</code></pre>
<p>Apart d’això tenim el mètode <code>#install</code> (i <code>#uninstall</code>, que és molt similar) que fa el <em>wrap</em> del mètode.</p>
<pre class="smalltalk"><code>install
    reference actualClass methodDictionary at: reference methodSymbol put: self</code></pre>
<p>Exemple d’execució:</p>
<pre class="smalltalk"><code>logger := LoggingMethodWrapper on: Integer&gt;&gt;#factorial.
logger invocationCount. &quot;0&quot;
5 factorial.
logger invocationCount. &quot;0&quot;
logger install.
[ 5 factorial ] ensure: [logger uninstall].
logger invocationCount. &quot;6&quot;
10 factorial.
logger invocationCount. &quot;6&quot;</code></pre>
<p>Al fer <em>wrap</em> d’un mètode totes les instàncies queden controlades, només s’intercepten els missatges conegurs (es pot controlar només un sol mètode) i no cal compilar per instal·lar.</p>
<h2 id="continuacions">Continuacions</h2>
<p>A Pharo 3.0 tenim la classe <code>Continuation</code> que serveix per guardar la pila d’execució en un moment donat.</p>
<pre class="smalltalk"><code>Object subclass: #Continuation
    instanceVariableNames: &#39;values&#39;
    classVariableNames: &#39;&#39;
    category: &#39;Kernel-Methods&#39;</code></pre>
<p>Per instanciar aquesta classe cal fer servir <code>#initialitzeFromContex: aContext</code>. Aquesta funció guarda a la variable d’instància <code>values</code> la pila associada al context que es passa com a argument.</p>
<pre class="smalltalk"><code>initializeFromContext: aContext
    | valueStream context |
    valueStream := WriteStream on: (Array new: 20).
    context := aContext.
    [context notNil] whileTrue:
        [valueStream nextPut: context.
        1 to: context class instSize do: [:i | valueStream nextPut: (context instVarAt: i)].
        1 to: context size do: [:i | valueStream nextPut: (context at: i)].
        context := context sender].
    values := valueStream contents</code></pre>
<p>Quan cridem a inicialitzar una nova continuacio amb un context, a partir del context donat (<code>context := aContext.</code>) itera per la seva pila d’execució fin al final (<code>[context notNil] whileTrue: [</code> … <code>context := context sender].</code>) i afageig el context (<code>valueStream nextPut: context.</code>) i les variables d’instància (<code>1 to: context class instSize do: [:i | valueStream nextPut: (context instVarAt: i)].</code>) i de classe (<code>1 to: context size do: [:i | valueStream nextPut: (context at: i)].</code>).</p>
<p>La classe <code>Continuation</code> té un mètode anomenat <code>#value: anObject</code> que, donat un objecte, recupera el context que teniem guardat, el converteix en el context actual i retorna l’objecte <code>anObject</code> per poder continuar l’execució del context tot just restaurat.</p>
<pre class="smalltalk"><code>| lletra |
lletra := Continuation new initializeFromContext: thisContext.
(lletra = $f)
    ifTrue:  [
        Transcript show: &#39;és la lletra f&#39; ; cr
    ]
    ifFalse: [
        Transcript show: lletra ; cr.
        lletra value: $f
    ].
Transcript show: lletra ; cr.</code></pre>
<p>Si executem aquest codi el que sortirà pel Transcrip és:</p>
<pre><code>a Continuation
és la lletra f
f</code></pre>
<p>El que fa aquest codi és crear una continuació amb el context actual i asignar-li a <code>lletra</code>. Després comprova si <code>lletra</code> és la lletra f, obviament no ho és perque acabem de dir que és una continuació aixi que executa el bloc <code>ifFalse</code>. Dintre d’aquell bloc mostra pel Transcript <em>a Continuation</em> i li dona el valor <code>$f</code> a la continuació <code>lletra</code>.</p>
<p>Allà és quan hi ha el canvi de context. Com he explicat abans el mètode <code>#value: anObject</code> recupera el context que teniem guardat, el converteix en l’actual i retorna <code>anObject</code>. Així doncs tornem a la linia on li assignavem <code>Continuation new ...</code> a <code>lletra</code> i retornem <code>$f</code>. Al convertir <code>thisContext</code> en el context actual l’execucó segueix a partir d’alla. Entrarà al bloc <code>ifTrue</code> i mostrarà <em>és la lletra f</em> i <em>f</em>.</p>
<h3 id="evaluar-continuacions-value-anobject">Evaluar continuacions: <code>#value: anObject</code></h3>
<pre class="smalltalk"><code>value: anObject
    self terminate: thisContext.
    self restoreValues.
    thisContext swapSender: values first.
    ^ anObject</code></pre>
<p>Aquest mètode, primer de tot elimina el context actual, per tant deixem d’estar en el moment en que s’ha cridat <code>#value:</code>. Acte seguit recupera la pila del moment en que s’ha inicialitzat la continuació. Finalment diu que el context actual és el primer de la pila cargada i retorna el valor que se li ha passat al mètode.</p>
<h3 id="call-current-continuation-callcc-ablock">Call current continuation: <code>#callcc: aBlock</code></h3>
<pre class="smalltalk"><code>callcc: aBlock
    ^ self currentDo: aBlock</code></pre>
<p>La idea d’aquest mètode és capturar el context actual en una instància i passar-li una continuació d’aquest context com a paràmetre a <code>aBlock</code> quan és evaluat.</p>
<p><em>WHAT!?…</em> Exacte, que?</p>
<p><code>#currentDo: aBlock</code> evalua el block donat amb el resultat de <code>self fromContext: thisContext sender</code>, és a dir, una continuació del context del <code>sender</code> (és el <code>sender</code> perque si no el context seria aquella mateixa linea del <code>currentDo</code> i no és el que volem). <code>fromContext</code> crida a <code>#initializeFromContext:</code>, i ja sabem que fa.</p>
<pre class="smalltalk"><code>currentDo: aBlock
    ^ aBlock value: (self fromContext: thisContext sender)</code></pre>
<pre class="smalltalk"><code>fromContext: aStack
    ^self new initializeFromContext: aStack</code></pre>
<p>Recapitulem: al invocar <code>callcc</code> amb un bloc <em>B</em>, evaluem el bloc <em>B</em> amb la continuació resultant del context on es crida <code>callcc</code> (<code>thisContext sender</code>).</p>
<h5 id="exemples-de-callcc-ablock">Exemples de <code>#callcc: aBlock</code></h5>
<pre class="smalltalk"><code>| x |
x := Continuation callcc: [ :cc | cc value: true ].
x &quot;print =&gt; true&quot;</code></pre>
<p>Al cridar <code>callcc</code> el que fem és evaluar el bloc <code>[ :cc | cc value: true ]</code> amb una continuació d’aquell context (aquesta continuació es crea dintre de <code>callcc</code>, a <code>currentDo</code>). Al evaluar el bloc amb la continuació, evaluem la continuació amb <code>true</code>, és a dir, x val true.</p>
<p>Podem afegir uns <code>Transcripts show:</code> per veure cuin és l’ordre en que s’executen les coses:</p>
<pre class="smalltalk"><code>| x |x := Continuation callcc: [ :cc |  Transcript show: &#39;Primer&#39;; cr.  cc value: true. Transcript show: &#39;Això mai d&#39;executa&#39;; cr. ].Transcript show: &#39;Segon&#39;; cr.Transcript show: x; cr.```

El resultat d&#39;aquest codi serà:
</code></pre>
<p>Primer Segon true ```</p>
<p>Un altre exemple per entendre el valor de <code>cc</code> i <code>x</code>:</p>
<p><code>smalltalk| cont x |x := Continuation callcc: [ :cc | cont := cc. cont value: 1 ].(x = 1) ifTrue: [       Transcript show: 'x = '.        Transcript show: x; cr.     cont value: 2 ] ifFalse: [      Transcript show: 'x = '.        Transcript show: x; cr. ].</code></p>
<p>El resultat d’aquest codi serà:</p>
<pre><code>x = 1
x = 2</code></pre>
<p>El evaluar el bloc del <code>callcc</code> guardem la continuació a la variable <code>cont</code> i l’evaluem amb valor <em>1</em>. Continuem i mirem que x sigui igual a <em>1</em>, obviament ho és perque acabem de donarli aquell valor. Dins del bloc del <code>ifTrue:</code> es torna a evaluar la continuació amb valor <em>2</em>.</p>
<pre class="smalltalk"><code>mentreCert: aBlock
    &quot;versió de whileTrue: implementada amb callcc:&quot;
    | cont |
    cont := Continuation callcc: [ :cc | cc ].          
    self value 
        ifTrue:  [ aBlock value. 
                   cont value: cont ]
        ifFalse: [ ^ nil].</code></pre>
<p>En aquest codi volem fer un bucle mentre el bloc <code>self</code> sigui cert. Així doncs, creem una <strong>continuació que serà evaluada en el bloc <code>[ :cc | cc ]</code></strong>. Després evaluem <code>self</code> (la condició del <em>whileTrue</em>), evaluem el bloc <code>aBlock</code> si és cert o sortim (amb <code>[ ^ nil ]</code>) si es fals. En cas de que sigui cert, després d’evaluar el bloc <code>aBlock</code>, <strong>evaluem <code>cont</code></strong> amb <code>cont</code> com a valor. Això li passa <code>cont</code> al bloc <code>[ :cc | cc ]</code>. Aquest bloc retorna <code>cc</code>, el <em>value</em> que li passis. Aixi que <code>cont</code> serà <strong>la mateixa continuacó d’abans, que serà evaluada en el bloc <code>[ :cc | cc ]</code></strong>. Tindrà el context d’aquell moment, l’execució continuarà desde aquell punt i tornarà a evaluar-se <code>self</code> com en un <code>whileTrue</code>.</p>
